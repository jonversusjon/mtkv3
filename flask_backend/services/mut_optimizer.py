from typing import Dict, List, Callable
import numpy as np
from itertools import product
from tqdm import tqdm

from flask_backend.models import Mutation, MutationSet, MutationSetCollection
from flask_backend.logging import logger
from flask_backend.services.utils import GoldenGateUtils


class MutationOptimizer:
    """
    MutationOptimizer Module

    This module optimizes mutation combinations generated by the MutationAnalyzer module
    for Golden Gate assembly compatibility. It evaluates alternative codon mutations based on
    sticky-end compatibility, selecting sets of mutations that satisfy the Golden Gate cloning criteria.
    """

    def __init__(self, verbose: bool = False, debug: bool = False):
        self.utils = GoldenGateUtils()
        self.verbose = verbose
        self.debug = debug

        if self.debug:
            logger.log_step("Initialization", "ðŸ” Debug mode enabled with detailed logging and validation")

        self.compatibility_table = self.utils.load_compatibility_table('flask_backend/static/data/compatibility_table.bin')
        logger.debug("MutationOptimizer initialized with compatibility table.")
        if self.verbose:
            logger.log_step("Initialization", "MutationOptimizer is running in verbose mode.")
        if self.debug:
            logger.validate(self.compatibility_table is not None, "Compatibility table loaded successfully")
            logger.validate(isinstance(self.compatibility_table, np.ndarray), "Compatibility table is a numpy array")

    def optimize_mutations(
        self,
        mutation_options: Dict[str, List[Mutation]],
        send_update: Callable,
    ) -> MutationSetCollection:
        logger.log_step("Start Optimization", "Beginning mutation optimization process.")
        
        logger.log_step("Generate Mutation Sets", "Creating all possible mutation combinations.")
        mutation_sets = self.generate_mutation_sets(mutation_options)
        logger.log_step("Generate Mutation Sets", f"Total mutation sets generated: {len(mutation_sets.sets)}")
                
        send_update(message=f"Generated {len(mutation_sets.sets)} mutation sets", prog=100,
                    rs_keys=mutation_sets.rs_keys,
                    mutation_sets=mutation_sets)
        
        return mutation_sets

    def generate_mutation_sets(self, mutation_options: Dict[str, List[Mutation]]) -> MutationSetCollection:
        """
        Generate all valid mutation sets using a generator-based approach for memory efficiency.
        Each mutation set contains exactly one mutation option per restriction site.
        
        Args:
            mutation_options: Dictionary mapping restriction site keys to lists of Mutation objects
            
        Returns:
            MutationSetCollection object containing all valid mutation sets
        """
        logger.validate(mutation_options and isinstance(mutation_options, dict),
                        f"Received {len(mutation_options)} mutation site(s)")
        logger.log_step("Generate Mutation Sets", "Generating all possible mutation combinations.")
        
        # List of all restriction site keys
        rs_keys = list(mutation_options.keys())

        mutation_set_collection = MutationSetCollection(
            rs_keys=rs_keys,
            sets=[]
        )
        
        if not rs_keys:
            logger.log_step("Generate Mutation Sets", "No restriction sites to process.")
            return mutation_set_collection
        
        valid_mutation_sets = []
        processed_count = 0
        valid_count = 0
        
        # Define a recursive generator function to build mutation sets efficiently
        def generate_sets(index=0, current_dict=None, current_mutation_list=None):
            nonlocal processed_count
            
            if current_dict is None:
                current_dict = {}
            if current_mutation_list is None:
                current_mutation_list = []
                
            # If we've added a mutation for every restriction site, yield the completed set
            if index >= len(rs_keys):
                processed_count += 1
                
                # Create a mutation set dictionary for compatibility matrix computation
                mutation_set_dict = [
                    {"overhangs": {"overhang_options": mutation.overhang_options}} 
                    for mutation in current_mutation_list
                ]
                
                # Compute compatibility matrix
                matrix = self.create_compatibility_matrix(mutation_set_dict)
                
                # Only yield valid mutation sets
                if np.any(matrix == 1):
                    yield MutationSet(
                        alt_codons=current_dict.copy(),  # create a copy to avoid reference issues
                        compatibility=matrix.tolist(),
                        mut_primer_sets=[]
                    )
                return
            
            # Get the current restriction site key
            key = rs_keys[index]
            
            # For each mutation option for this restriction site
            for mutation in mutation_options[key]:
                # Add this mutation to our current set
                next_dict = current_dict.copy()
                next_dict[key] = mutation
                next_list = current_mutation_list.copy()
                next_list.append(mutation)
                
                # Recursively generate sets with this mutation added
                yield from generate_sets(index + 1, next_dict, next_list)
        
        # Use the progress bar for overall progress tracking
        total_combinations = 1
        for key in rs_keys:
            total_combinations *= len(mutation_options[key])
            
        with tqdm(total=total_combinations, desc="Processing Mutation Sets", unit="set") as pbar:
            # Collect all valid mutation sets
            for valid_set in generate_sets():
                valid_mutation_sets.append(valid_set)
                valid_count += 1
                
                # Update progress bar periodically
                if valid_count % 100 == 0 or processed_count % 1000 == 0:
                    pbar.update(min(1000, processed_count - pbar.n))
                    
            # Ensure progress bar is completed
            pbar.update(total_combinations - pbar.n)
        
        mutation_set_collection.sets = valid_mutation_sets
        
        logger.log_step("Generate Mutation Sets", 
                        f"Processed {processed_count} combinations, found {valid_count} valid mutation sets")
        
        return mutation_set_collection

    def create_compatibility_matrix(self, mutation_set: list) -> np.ndarray:
        """
        Given a mutation_set (a list where each entry is a dict in the format:
            {"overhangs": {"overhang_options": List[OverhangOption]}}),
        compute and return its compatibility matrix as a numpy ndarray.
        """
        # Build list of overhang option lists for each mutation entry.
        overhang_lists = [entry["overhangs"]["overhang_options"] for entry in mutation_set]
        # Determine the shape of the compatibility matrix.
        shape = tuple(len(options) for options in overhang_lists)
        matrix = np.zeros(shape, dtype=int)
        
        # Iterate over every combination of indices corresponding to overhang options for each site.
        for combo_indices in product(*[range(len(options)) for options in overhang_lists]):
            # Retrieve the chosen OverhangOption objects for this combination.
            combo = tuple(overhang_lists[i][idx] for i, idx in enumerate(combo_indices))
            n = len(combo)
            # Check if all pairs of chosen overhangs are compatible based on their top_overhang attribute.
            if all(
                self.compatibility_table[self.utils.seq_to_index(combo[i].top_overhang)]
                [self.utils.seq_to_index(combo[j].top_overhang)] == 1
                for i in range(n) for j in range(i + 1, n)
            ):
                matrix[combo_indices] = 1

        return matrix
