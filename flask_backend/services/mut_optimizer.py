from typing import Dict, List, Callable
import numpy as np
from itertools import product

from flask_backend.models import Mutation, MutationSet, MutationSetCollection
# from flask_backend.logging import logger
from flask_backend.services.utils import GoldenGateUtils


class MutationOptimizer:
    """
    MutationOptimizer Module

    This module optimizes mutation combinations generated by the MutationAnalyzer module
    for Golden Gate assembly compatibility. It evaluates alternative codon mutations based on
    sticky-end compatibility, selecting sets of mutations that satisfy the Golden Gate cloning criteria.
    """

    def __init__(self, verbose: bool = False, debug: bool = False):
        self.utils = GoldenGateUtils()
        self.verbose = verbose
        self.debug = debug

        # if self.debug:
        #     logger.log_step(
        #         "Initialization",
        #         "ðŸ” Debug mode enabled with detailed logging and validation",
        #     )

        self.compatibility_table = self.utils.load_compatibility_table(
            "flask_backend/static/data/compatibility_table.bin"
        )
        # logger.debug("MutationOptimizer initialized with compatibility table.")
        # if self.verbose:
        #     logger.log_step(
        #         "Initialization", "MutationOptimizer is running in verbose mode."
        #     )
        # if self.debug:
        #     logger.validate(
        #         self.compatibility_table is not None,
        #         "Compatibility table loaded successfully",
        #     )
        #     logger.validate(
        #         isinstance(self.compatibility_table, np.ndarray),
        #         "Compatibility table is a numpy array",
        #     )

    def optimize_mutations(
        self,
        mutation_options: Dict[str, List[Mutation]],
        send_update: Callable,
    ) -> MutationSetCollection:
        # logger.log_step(
        #     "Start Optimization", "Beginning mutation optimization process."
        # )

        # logger.log_step(
        #     "Generate Mutation Sets", "Creating all possible mutation combinations."
        # )
        mutation_sets = self.generate_mutation_sets(mutation_options, send_update)
        # logger.log_step(
        #     "Generate Mutation Sets",
        #     f"Total mutation sets generated: {len(mutation_sets.sets)}",
        # )

        send_update(
            message=f"Generated {len(mutation_sets.sets)} mutation sets",
            prog=100,
            rs_keys=mutation_sets.rs_keys,
            mutation_sets=mutation_sets,
        )

        return mutation_sets

    def generate_mutation_sets(
        self, mutation_options: Dict[str, List[Mutation]], send_update: Callable = None
    ) -> MutationSetCollection:
        """
        Generate all valid mutation sets using a generator-based approach for memory efficiency.
        Each mutation set contains exactly one mutation option per restriction site.

        Args:
            mutation_options: Dictionary mapping restriction site keys to lists of Mutation objects
            send_update: Optional callback for sending progress updates

        Returns:
            MutationSetCollection object containing all valid mutation sets
        """
        # logger.validate(
        #     mutation_options and isinstance(mutation_options, dict),
        #     f"Received {len(mutation_options)} mutation site(s)",
        # )
        # logger.log_step(
        #     "Generate Mutation Sets", "Generating all possible mutation combinations."
        # )

        # List of all restriction site keys
        rs_keys = list(mutation_options.keys())

        mutation_set_collection = MutationSetCollection(rs_keys=rs_keys, sets=[])

        if not rs_keys:
            # logger.log_step(
            #     "Generate Mutation Sets", "No restriction sites to process."
            # )
            return mutation_set_collection

        valid_mutation_sets = []
        processed_count = 0
        valid_count = 0

        # Define a recursive generator function to build mutation sets efficiently
        def generate_sets(index=0, current_dict=None, current_mutation_list=None):
            nonlocal processed_count

            if current_dict is None:
                current_dict = {}
            if current_mutation_list is None:
                current_mutation_list = []

            # If we've added a mutation for every restriction site, yield the completed set
            if index >= len(rs_keys):
                processed_count += 1

                # Create a mutation set dictionary for compatibility matrix computation
                mutation_set_dict = [
                    {"overhangs": {"overhang_options": mutation.overhang_options}}
                    for mutation in current_mutation_list
                ]

                # Compute compatibility matrix
                matrix = self.create_compatibility_matrix(mutation_set_dict)

                # Only yield valid mutation sets
                if np.any(matrix == 1):
                    yield MutationSet(
                        alt_codons=current_dict.copy(),  # create a copy to avoid reference issues
                        compatibility=matrix.tolist(),
                        mut_primer_sets=[],
                    )
                return

            # Get the current restriction site key
            key = rs_keys[index]

            # For each mutation option for this restriction site
            for mutation in mutation_options[key]:
                # Add this mutation to our current set
                next_dict = current_dict.copy()
                next_dict[key] = mutation
                next_list = current_mutation_list.copy()
                next_list.append(mutation)

                # Recursively generate sets with this mutation added
                yield from generate_sets(index + 1, next_dict, next_list)

        # Calculate total combinations for progress reporting
        total_combinations = 1
        for key in rs_keys:
            total_combinations *= len(mutation_options[key])

        # Send initial progress update
        if send_update:
            send_update(
                message=f"Starting to process {total_combinations:,} potential mutation combinations",
                prog=5,
            )

        # Set up progress reporting intervals based on total combinations
        update_interval = max(
            1, min(1000, total_combinations // 20)
        )  # Update at most 20 times
        last_update_count = 0

        # Collect all valid mutation sets
        for valid_set in generate_sets():
            valid_mutation_sets.append(valid_set)
            valid_count += 1

            # Send updates to frontend at regular intervals
            if send_update and (processed_count - last_update_count >= update_interval):
                progress = min(90, int(5 + (processed_count / total_combinations * 85)))
                send_update(
                    message=f"Processed {processed_count:,} of {total_combinations:,} combinations; Found {valid_count:,} valid sets",
                    prog=progress,
                    mutation_count=valid_count,
                )
                last_update_count = processed_count

        mutation_set_collection.sets = valid_mutation_sets

        # logger.log_step(
        #     "Generate Mutation Sets",
        #     f"Processed {processed_count} combinations, found {valid_count} valid mutation sets",
        # )

        # Final update
        if send_update:
            send_update(
                message=f"Completed processing. Found {valid_count:,} valid mutation sets out of {processed_count:,} combinations",
                prog=95,
                mutation_count=valid_count,
            )

        return mutation_set_collection

    def create_compatibility_matrix(self, mutation_set: list) -> np.ndarray:
        """
        Compute compatibility matrix for a single mutation set.
        """
        overhang_lists = [
            entry["overhangs"]["overhang_options"] for entry in mutation_set
        ]
        shape = tuple(len(options) for options in overhang_lists)
        matrix = np.zeros(shape, dtype=int)

        for combo_indices in product(
            *[range(len(options)) for options in overhang_lists]
        ):
            combo = tuple(overhang_lists[i][idx] for i, idx in enumerate(combo_indices))
            if all(
                self.compatibility_table[
                    self.utils.seq_to_index(combo[i].top_overhang)
                ][self.utils.seq_to_index(combo[j].top_overhang)]
                == 1
                for i in range(len(combo))
                for j in range(i + 1, len(combo))
            ):
                matrix[combo_indices] = 1

        return matrix

    def check_single_mutation_set_compatibility(self, mutation_set):
        """
        Check compatibility of a single mutation set.
        """
        matrix = self.create_compatibility_matrix(mutation_set)
        return np.any(matrix == 1)
