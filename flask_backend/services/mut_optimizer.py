from typing import Dict, List
import numpy as np
from itertools import product
from tqdm import tqdm

from flask_backend.models import Mutation, MutationSet, MutationSetCollection
from flask_backend.logging import logger
from flask_backend.services.utils import GoldenGateUtils


class MutationOptimizer():
    """
    MutationOptimizer Module

    This module optimizes mutation combinations generated by the MutationAnalyzer module
    for Golden Gate assembly compatibility. It evaluates alternative codon mutations based on
    sticky-end compatibility, selecting sets of mutations that satisfy the Golden Gate cloning criteria.
    """

    def __init__(self, verbose: bool = False, debug: bool = False):
        self.utils = GoldenGateUtils()
        self.verbose = verbose
        self.debug = debug

        if self.debug:
            logger.log_step("Initialization", "ðŸ” Debug mode enabled with detailed logging and validation")

        self.compatibility_table = self.utils.load_compatibility_table('flask_backend/static/data/compatibility_table.bin')
        logger.debug("MutationOptimizer initialized with compatibility table.")
        if self.verbose:
            logger.log_step("Initialization", "MutationOptimizer is running in verbose mode.")
        if self.debug:
            logger.validate(self.compatibility_table is not None,
                            "Compatibility table loaded successfully")
            logger.validate(isinstance(self.compatibility_table, np.ndarray),
                            "Compatibility table is a numpy array")

    def optimize_mutations(
        self,
        mutation_options: Dict,
        send_update: callable,
        ) -> MutationSetCollection:
        logger.log_step("Start Optimization", "Beginning mutation optimization process.")
        
        logger.log_step("Generate Mutation Sets", "Creating all possible mutation combinations.")
        mutation_sets = self.generate_mutation_sets(mutation_options)
        logger.log_step("Generate Mutation Sets", f"Total mutation sets generated: {len(mutation_sets.sets)}")
                
        send_update(message=f"Generated {len(mutation_sets.sets)} mutation sets", prog=100,
                    rs_keys=mutation_sets.rs_keys,
                    mutation_sets=mutation_sets)
        
        return mutation_sets

    def generate_mutation_sets(self, mutation_options: Dict[str, List[Mutation]]) -> MutationSetCollection:
        logger.validate(mutation_options and isinstance(mutation_options, dict),
                        f"Received {len(mutation_options)} mutation site(s)")
        logger.log_step("Generate Mutation Sets", "Generating all possible mutation combinations.")
        
        # List of all restriction site keys
        rs_keys = list(mutation_options.keys())
        mutation_options_by_site = [mutation_options[site] for site in rs_keys]

        mutation_set_collection = MutationSetCollection(
            rs_keys=rs_keys,
            sets=[]
        )
        
        valid_mutation_sets = []
        
        # Iterate over each candidate tuple in the Cartesian product.
        for mutation_tuple in tqdm(product(*mutation_options_by_site), desc="Processing Mutation Sets", unit="set"):
            # Build a complete candidate mapping: one mutation per rsKey.
            candidate_dict = {rs_keys[i]: mutation for i, mutation in enumerate(mutation_tuple)}
            
            # Prepare data for compatibility matrix computation.
            # This remains similar to beforeâ€”each mutation's overhang options are extracted.
            mutation_set_dict = [
                {"overhangs": {"overhang_options": mutation.overhang_options}} 
                for mutation in mutation_tuple
            ]
            
            # Compute the compatibility matrix.
            matrix = self.create_compatibility_matrix(mutation_set_dict)
            
            # Only add the mutation set if the matrix has at least one valid (1) entry.
            if np.any(matrix == 1):
                valid_mutation_sets.append(
                    MutationSet(
                        alt_codons=candidate_dict,  # now using the new field name
                        compatibility=matrix.tolist(),
                        mut_primer_sets=[]
                    )
                )
        
        mutation_set_collection.sets = valid_mutation_sets
        
        return mutation_set_collection


    def create_compatibility_matrix(self, mutation_set: list) -> np.ndarray:
        """
        Given a mutation_set (a list where each entry is a dict in the format:
            {"overhangs": {"overhang_options": List[OverhangOption]}}),
        compute and return its compatibility matrix as a numpy ndarray.
        """
        # Build list of overhang option lists for each mutation entry.
        overhang_lists = [entry["overhangs"]["overhang_options"] for entry in mutation_set]
        # Determine the shape of the compatibility matrix.
        shape = tuple(len(options) for options in overhang_lists)
        matrix = np.zeros(shape, dtype=int)
        
        # Iterate over every combination of indices corresponding to overhang options for each site.
        for combo_indices in product(*[range(len(options)) for options in overhang_lists]):
            # Retrieve the chosen OverhangOption objects for this combination.
            combo = tuple(overhang_lists[i][idx] for i, idx in enumerate(combo_indices))
            n = len(combo)
            # Check if all pairs of chosen overhangs are compatible based on their top_overhang attribute.
            if all(
                self.compatibility_table[self.utils.seq_to_index(combo[i].top_overhang)]
                [self.utils.seq_to_index(combo[j].top_overhang)] == 1
                for i in range(n) for j in range(i + 1, n)
            ):
                matrix[combo_indices] = 1

        return matrix
